var searchIndex = {};
searchIndex['num_traits'] = {"items":[[0,"","num_traits","Numeric traits for generic mathematics.",null,null],[8,"Int","","Signed and unsigned integers.",null,null],[10,"min_value","","Returns the smallest value that can be represented by this numeric type.",0,{"inputs":[{"name":"int"}],"output":{"name":"self"}}],[10,"max_value","","Returns the largest value that can be represented by this numeric type.",0,{"inputs":[{"name":"int"}],"output":{"name":"self"}}],[10,"from_str_radix","","Converts a string slice in a given base to an integer.",0,{"inputs":[{"name":"int"},{"name":"str"},{"name":"u32"}],"output":{"name":"result"}}],[10,"count_ones","","Returns the number of ones in the binary representation of `self`.",0,{"inputs":[{"name":"int"}],"output":{"name":"u32"}}],[10,"count_zeros","","Returns the number of zeros in the binary representation of `self`.",0,{"inputs":[{"name":"int"}],"output":{"name":"u32"}}],[10,"leading_zeros","","Returns the number of leading zeros in the binary representation of `self`.",0,{"inputs":[{"name":"int"}],"output":{"name":"u32"}}],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of `self`.",0,{"inputs":[{"name":"int"}],"output":{"name":"u32"}}],[10,"rotate_left","","Shifts the bits to the left by a specified amount, `n`,\nwrapping the truncated bits to the end of the resulting integer.",0,{"inputs":[{"name":"int"},{"name":"u32"}],"output":{"name":"self"}}],[10,"rotate_right","","Shifts the bits to the right by a specified amount, `n`,\nwrapping the truncated bits to the beginning of the resulting integer.",0,{"inputs":[{"name":"int"},{"name":"u32"}],"output":{"name":"self"}}],[10,"swap_bytes","","Reverses the byte order of the integer.",0,{"inputs":[{"name":"int"}],"output":{"name":"self"}}],[10,"from_be","","Converts an integer from big endian to the target's endianness.",0,{"inputs":[{"name":"int"},{"name":"self"}],"output":{"name":"self"}}],[10,"from_le","","Converts an integer from little endian to the target's endianness.",0,{"inputs":[{"name":"int"},{"name":"self"}],"output":{"name":"self"}}],[10,"to_be","","Converts `self` to big endian from the target's endianness.",0,{"inputs":[{"name":"int"}],"output":{"name":"self"}}],[10,"to_le","","Converts `self` to little endian from the target's endianness.",0,{"inputs":[{"name":"int"}],"output":{"name":"self"}}],[10,"checked_add","","Checked integer addition. Computes `self + other`,\nreturning `None` if overflow occurred.",0,{"inputs":[{"name":"int"},{"name":"self"}],"output":{"name":"option"}}],[10,"checked_sub","","Checked integer subtraction. Computes `self - other`,\nreturning `None` if underflow occurred.",0,{"inputs":[{"name":"int"},{"name":"self"}],"output":{"name":"option"}}],[10,"checked_mul","","Checked integer multiplication. Computes `self * other`,\nreturning `None` if underflow or overflow occurred.",0,{"inputs":[{"name":"int"},{"name":"self"}],"output":{"name":"option"}}],[10,"checked_div","","Checked integer division. Computes `self / other`,\nreturning `None` if `other == 0` or the operation results in underflow or overflow.",0,{"inputs":[{"name":"int"},{"name":"self"}],"output":{"name":"option"}}],[10,"saturating_add","","Saturating integer addition. Computes `self + other`,\nsaturating at the numeric bounds instead of overflowing.",0,{"inputs":[{"name":"int"},{"name":"self"}],"output":{"name":"self"}}],[10,"saturating_sub","","Saturating integer subtraction. Computes `self - other`,\nsaturating at the numeric bounds instead of overflowing.",0,{"inputs":[{"name":"int"},{"name":"self"}],"output":{"name":"self"}}],[10,"wrapping_add","","Wrapping (modular) addition. Computes `self + other`,\nwrapping around at the boundary of the type.",0,{"inputs":[{"name":"int"},{"name":"self"}],"output":{"name":"self"}}],[10,"wrapping_sub","","Wrapping (modular) subtraction. Computes `self - other`,\nwrapping around at the boundary of the type.",0,{"inputs":[{"name":"int"},{"name":"self"}],"output":{"name":"self"}}],[10,"wrapping_mul","","Wrapping (modular) multiplication. Computes `self * other`,\nwrapping around at the boundary of the type.",0,{"inputs":[{"name":"int"},{"name":"self"}],"output":{"name":"self"}}],[10,"wrapping_div","","Wrapping (modular) division. Computes `self / other`,\nwrapping around at the boundary of the type.",0,{"inputs":[{"name":"int"},{"name":"self"}],"output":{"name":"self"}}],[10,"wrapping_rem","","Wrapping (modular) remainder. Computes `self % other`,\nwrapping around at the boundary of the type.",0,{"inputs":[{"name":"int"},{"name":"self"}],"output":{"name":"self"}}],[10,"wrapping_neg","","Wrapping (modular) negation. Computes ``-self`,\nwrapping around at the boundary of the type.",0,{"inputs":[{"name":"int"}],"output":{"name":"self"}}],[10,"wrapping_shl","","Panic-free bitwise shift-left; yields `self << mask(rhs)`,\nwhere `mask` removes any high-order bits of rhs that would\ncause the shift to exceed the bitwidth of the type.",0,{"inputs":[{"name":"int"},{"name":"u32"}],"output":{"name":"self"}}],[10,"wrapping_shr","","Panic-free bitwise shift-left; yields `self >> mask(rhs)`,\nwhere mask removes any high-order bits of rhs that would\ncause the shift to exceed the bitwidth of the type.",0,{"inputs":[{"name":"int"},{"name":"u32"}],"output":{"name":"self"}}],[10,"pow","","Raises self to the power of `exp`, using exponentiation by squaring.",0,{"inputs":[{"name":"int"},{"name":"u32"}],"output":{"name":"self"}}],[8,"UnsignedInt","","Unsigned integers.",null,null],[10,"is_power_of_two","","Returns true if and only if `self == 2^k` for some `k`.",1,{"inputs":[{"name":"unsignedint"}],"output":{"name":"bool"}}],[10,"next_power_of_two","","Returns the smallest power of two greater than or equal to `self`.\nUnspecified behavior on overflow.",1,{"inputs":[{"name":"unsignedint"}],"output":{"name":"self"}}],[10,"checked_next_power_of_two","","Returns the smallest power of two greater than or equal to `n`.\nIf the next power of two is greater than the type's maximum value,\n`None` is returned, otherwise the power of two is wrapped in `Some`.",1,{"inputs":[{"name":"unsignedint"}],"output":{"name":"option"}}],[8,"Float","","Float numbers.",null,null],[10,"nan","","Returns the `NaN` value.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"infinity","","Returns the infinite value.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"neg_infinity","","Returns the negative infinite value.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"neg_zero","","Returns `-0.0`.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"min_value","","Returns the smallest value that can be represented by this numeric type.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"max_value","","Returns the largest value that can be represented by this numeric type.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"is_nan","","Returns `true` if this value is `NaN` and false otherwise.",2,{"inputs":[{"name":"float"}],"output":{"name":"bool"}}],[10,"is_infinite","","Returns `true` if this value is positive infinity or negative infinity and false otherwise.",2,{"inputs":[{"name":"float"}],"output":{"name":"bool"}}],[10,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",2,{"inputs":[{"name":"float"}],"output":{"name":"bool"}}],[10,"is_normal","","Returns `true` if the number is neither zero, infinite, [subnormal][subnormal], or `NaN`.",2,{"inputs":[{"name":"float"}],"output":{"name":"bool"}}],[10,"classify","","Returns the floating point category of the number. If only one property is going to\nbe tested, it is generally faster to use the specific predicate instead.",2,{"inputs":[{"name":"float"}],"output":{"name":"fpcategory"}}],[10,"floor","","Returns the largest integer less than or equal to a number.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"ceil","","Returns the smallest integer greater than or equal to a number.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"round","","Returns the nearest integer to a number. Round half-way cases away from `0.0`.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"trunc","","Return the integer part of a number.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"fract","","Returns the fractional part of a number.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0` and `Float::infinity()`.",2,{"inputs":[{"name":"float"}],"output":{"name":"bool"}}],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0` and `Float::neg_infinity()`.",2,{"inputs":[{"name":"float"}],"output":{"name":"bool"}}],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only one rounding error.\nThis produces a more accurate result with better performance than\na separate multiplication operation followed by an add.",2,{"inputs":[{"name":"float"},{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"powi","","Raise a number to an integer power.",2,{"inputs":[{"name":"float"},{"name":"i32"}],"output":{"name":"self"}}],[10,"powf","","Raise a number to a floating point power.",2,{"inputs":[{"name":"float"},{"name":"self"}],"output":{"name":"self"}}],[10,"sqrt","","Take the square root of a number. Returns NaN if `self` is a negative number.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"exp","","Returns `e^(self)`, (the exponential function).",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"exp2","","Returns `2^(self)`.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"ln","","Returns the natural logarithm of the number.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"log","","Returns the logarithm of the number with respect to an arbitrary base.",2,{"inputs":[{"name":"float"},{"name":"self"}],"output":{"name":"self"}}],[10,"log2","","Returns the base 2 logarithm of the number.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"log10","","Returns the base 10 logarithm of the number.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"max","","Returns the maximum of the two numbers.",2,{"inputs":[{"name":"float"},{"name":"self"}],"output":{"name":"self"}}],[10,"min","","Returns the minimum of the two numbers.",2,{"inputs":[{"name":"float"},{"name":"self"}],"output":{"name":"self"}}],[10,"abs_sub","","The positive difference of two numbers.",2,{"inputs":[{"name":"float"},{"name":"self"}],"output":{"name":"self"}}],[10,"cbrt","","Take the cubic root of a number.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle triangle given legs\nof length `x` and `y`.",2,{"inputs":[{"name":"float"},{"name":"self"}],"output":{"name":"self"}}],[10,"sin","","Computes the sine of a number (in radians).",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"cos","","Computes the cosine of a number (in radians).",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"tan","","Computes the tangent of a number (in radians).",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"asin","","Computes the arcsine of a number. Return value is in radians in the range\n[-pi/2, pi/2] or NaN if the number is outside the range [-1, 1].",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"acos","","Computes the arccosine of a number. Return value is in radians in the range\n[0, pi] or NaN if the number is outside the range [-1, 1].",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"atan","","Computes the arctangent of a number. Return value is in radians in the range\n[-pi/2, pi/2].",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).",2,{"inputs":[{"name":"float"},{"name":"self"}],"output":{"name":"self"}}],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number, `x`.\nReturns `(sin(x), cos(x))`.",2,null],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if the number is close to zero.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than if\nthe operations were performed separately.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"sinh","","Hyperbolic sine function.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"cosh","","Hyperbolic cosine function.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"tanh","","Hyperbolic tangent function.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"asinh","","Inverse hyperbolic sine function.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"acosh","","Inverse hyperbolic cosine function.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[10,"atanh","","Inverse hyperbolic tangent function.",2,{"inputs":[{"name":"float"}],"output":{"name":"self"}}],[8,"Signed","","Signed numbers.",null,null],[10,"abs","","Computes the absolute value.",3,{"inputs":[{"name":"signed"}],"output":{"name":"self"}}],[10,"signum","","Returns the sign of the number.",3,{"inputs":[{"name":"signed"}],"output":{"name":"self"}}],[10,"is_positive","","Returns true if the number is positive and false if the number is zero or negative.",3,{"inputs":[{"name":"signed"}],"output":{"name":"bool"}}],[10,"is_negative","","Returns true if the number is negative and false if the number is zero or positive.",3,{"inputs":[{"name":"signed"}],"output":{"name":"bool"}}],[8,"Zero","","Types that have a `zero` value.",null,null],[10,"zero","","Returns the `zero` (usually, additive identity) for this type.",4,{"inputs":[{"name":"zero"}],"output":{"name":"self"}}],[8,"One","","Types that have a `one` value.",null,null],[10,"one","","Returns the `one` (usually, multiplicative identity) for this type.",5,{"inputs":[{"name":"one"}],"output":{"name":"self"}}],[8,"Cast","","An interface for casting values.",null,null],[10,"cast","","Casts from `Self` to type `T`.",6,{"inputs":[{"name":"cast"}],"output":{"name":"option"}}]],"paths":[[8,"Int"],[8,"UnsignedInt"],[8,"Float"],[8,"Signed"],[8,"Zero"],[8,"One"],[8,"Cast"]]};
initSearch(searchIndex);
